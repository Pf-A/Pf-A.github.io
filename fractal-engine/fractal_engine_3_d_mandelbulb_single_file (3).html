<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Mandelbulb Test - WASD + Mouse + FPS</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    #instructions {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.7);
      color: white;
      font-family: sans-serif;
      text-align: center;
    }
    #fpsCounter {
      position: absolute;
      top: 10px;
      left: 10px;
      color: lime;
      font-family: monospace;
      font-size: 14px;
      background: rgba(0,0,0,0.5);
      padding: 4px 8px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="instructions">
    <span>Click to lock mouse and use WASD to move</span>
  </div>
  <div id="fpsCounter">FPS: 0</div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/PointerLockControls.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // PointerLockControls
    const controls = new PointerLockControls(camera, document.body);
    const instructions = document.getElementById('instructions');

    instructions.addEventListener('click', () => {
      controls.lock();
    });

    controls.addEventListener('lock', () => {
      instructions.style.display = 'none';
    });

    controls.addEventListener('unlock', () => {
      instructions.style.display = 'flex';
    });

    scene.add(controls.getObject());

    // Movement variables
    const move = { forward: false, backward: false, left: false, right: false };
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();

    document.addEventListener('keydown', (e) => {
      switch(e.code){
        case 'KeyW': move.forward = true; break;
        case 'KeyS': move.backward = true; break;
        case 'KeyA': move.left = true; break;
        case 'KeyD': move.right = true; break;
      }
    });
    document.addEventListener('keyup', (e) => {
      switch(e.code){
        case 'KeyW': move.forward = false; break;
        case 'KeyS': move.backward = false; break;
        case 'KeyA': move.left = false; break;
        case 'KeyD': move.right = false; break;
      }
    });

    // Fullscreen quad with Mandelbulb shader
    const uniforms = {
      iTime: { value: 0 },
      iResolution: { value: new THREE.Vector3(window.innerWidth, window.innerHeight, 1) },
      camPos: { value: new THREE.Vector3(0, 0, 5) },
      camDir: { value: new THREE.Vector3(0, 0, -1) },
    };

    const material = new THREE.ShaderMaterial({
      uniforms,
      vertexShader: `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float iTime;
        uniform vec3 iResolution;
        uniform vec3 camPos;
        uniform vec3 camDir;
        varying vec2 vUv;

        float mandelbulbDE(vec3 pos) {
          vec3 z = pos;
          float dr = 1.0;
          float r = 0.0;
          const int Iterations = 12;
          const float Power = 8.0;
          for (int i = 0; i < Iterations; i++) {
            r = length(z);
            if (r > 2.0) break;

            float theta = acos(z.z / r);
            float phi = atan(z.y, z.x);
            dr = pow(r, Power - 1.0) * Power * dr + 1.0;

            float zr = pow(r, Power);
            theta *= Power;
            phi *= Power;

            z = zr * vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
            z += pos;
          }
          return 0.5 * log(r) * r / dr;
        }

        void main(){
          vec2 uv = (vUv - 0.5) * 2.0;
          vec3 dir = normalize(vec3(uv, -1.5));
          vec3 pos = camPos;

          float totalDist = 0.0;
          bool hit = false;
          for(int i=0; i<64; i++){
            vec3 p = pos + dir * totalDist;
            float d = mandelbulbDE(p);
            if(d < 0.001){
              hit = true;
              break;
            }
            if(totalDist > 20.0) break;
            totalDist += d;
          }

          if(hit){
            gl_FragColor = vec4(vec3(0.8, 0.8, 0.9) * (1.0 - totalDist/20.0), 1.0);
          } else {
            gl_FragColor = vec4(0.0);
          }
        }
      `,
      depthWrite: false
    });

    const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
    scene.add(quad);

    camera.position.z = 1;

    const clock = new THREE.Clock();
    const fpsCounter = document.getElementById('fpsCounter');
    let lastTime = performance.now();
    let frames = 0;

    function animate(){
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      if(controls.isLocked){
        direction.z = Number(move.forward) - Number(move.backward);
        direction.x = Number(move.right) - Number(move.left);
        direction.normalize();

        if(move.forward || move.backward) velocity.z -= direction.z * 20.0 * delta;
        if(move.left || move.right) velocity.x -= direction.x * 20.0 * delta;

        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);

        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

        uniforms.camPos.value.copy(controls.getObject().position);
      }

      uniforms.iTime.value += delta;
      renderer.render(scene, camera);

      // FPS counter update
      frames++;
      const now = performance.now();
      if(now - lastTime >= 1000){
        fpsCounter.textContent = `FPS: ${frames}`;
        frames = 0;
        lastTime = now;
      }
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      uniforms.iResolution.value.set(window.innerWidth, window.innerHeight, 1);
    });
  </script>
</body>
</html>